# 函数调用

## 调用的过程

进程是一个资源单位，真正执行代码的是线程，线程启动的时候，先为他分配一段内存，
分为两块，一个为栈-->执行栈（函数参数、返回值），一个为堆（new、malloc），堆上的内存需要free\GC

函数调用主要是在栈上执行，栈和堆不同，堆是一个平面结构，栈是先进后出的一个空间，栈空间一般都追求重复使用，那么这里就有一个问题：
栈如何知道哪一段空间是用来维护你这个main函数的执行逻辑，（这里说main函数主要是，我们一个项目main函数是唯一的入口）
这里就需要用到两个寄存器，一个是BP一个是SP，BP寄存器指向栈的底部，SP指向栈的顶部，当调用的时候，SP会不断向上增长。

注意BP这个栈指针是指向当前执行函数的底部。所以，当我们调用一个函数的时候，首先需要做现场保护，如栈指针的值，上下文的信息
当调用完成之后，我们需要做现场恢复，所以这里就需要另一个寄存器，IP寄存器的值也需要保护起来，
IP保存了执行完成某一个函数的时候，需要执行的下一条指令。

每一个函数在栈上的一个执行空间我们称为：桢（Frame），所有的这些栈桢合起来我们称为：调用堆栈（call stack）

### 总结：

当mian函数调用add函数的时候，步骤如下：

1. 调用call指令，然后push（保存）IP指令。
2. 然后在函数头部，又把BP push（保护）进来。
3. 挪动栈指针，将SP的值赋值给BP，`mov rsp rbp`
4. 然后调用sub指令，向上移动SP的指针
5. 然后把SP pop出来，使用的levelq这个系统命令，来完成现场恢复
6. 把BP的值写给SP，那么刚才调用的那段空间就会被释放。
7. 然后把保存BP的那段空间pop出来，BP回到初始位置
8. 接下来还有一个retq指令，把IP寄存器pop出来，恢复到初始状态。

栈空间栈底的位置大，栈顶的位置小，所以SP要向上移动，就需要做减法往上移动栈的指针。

所有编译器的寻址都是基于BP寄存器来寻址的，做减法，减去偏移量。

栈上没有内存释放这么个说法，它只是通过移动BP和SP的位置来处理，要释放的话，就把整个栈空间释放
所以，我们尽可能把对象分配到栈上。垃圾回收器只管堆上的内存，不管栈上的空间。

指针本身是一个标准的变量，它是可以被赋值的。

### 参数传递

假设我们需要分配0x30 这么大的空间，按照8字节对其，会分配6个8 这样的堆栈空间。

go不使用BP寄存器，它是基于SP寄存器做加法的。gcc是基于BP寄存器做加法。


比如，一个简单的加法运算，x+y

* 先在一个格子里分配 x=100 ，继续分配 x=200 ,然后分别复制参数100、200
* 执行add的函数调用
* 在执行函数调用的时候，参数会被复制。
* 由调用方准备参数使用的空间，初始过程先赋值为0，当拿到具体的值的时候，再去覆盖这个位置。

![image.png](https://upload-images.jianshu.io/upload_images/6967649-ea43ee8a9c07b0da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

栈空间分为两部分，一部分留给自己本地的局部变量使用，一部分留给函数调用的过程使用。
